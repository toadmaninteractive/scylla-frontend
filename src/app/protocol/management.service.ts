// Author: Igor compiler
// Compiler version: igorc 2.1.4
// DO NOT EDIT THIS FILE - it is machine generated

import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import * as Igor from './igor';
import * as DataProtocol from './data';
import * as WebProtocol from './web';

@Injectable({
    providedIn: 'root',
})
export class ScyllaManagementService {
    public baseUrl = '';

    constructor(private http: HttpClient) { }

    public getClickhouseInstances(apiKey: string | null = null): Observable<DataProtocol.Collection<WebProtocol.ClickhouseInstance>> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .get(`${this.baseUrl}/clickhouse`, options)
            .pipe(
                map(response => DataProtocol.Collection.instanceJsonSerializer<WebProtocol.ClickhouseInstance>(WebProtocol.ClickhouseInstance).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createClickhouseInstance(request: WebProtocol.CreateClickhouseInstanceRequest, apiKey: string | null = null): Observable<WebProtocol.ClickhouseInstance> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json', 'content-type': "application/json", 'x-api-key': `${apiKey}`}) };

        return this.http
            .post(`${this.baseUrl}/clickhouse`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<WebProtocol.ClickhouseInstanceError>(WebProtocol.ClickhouseInstanceError).fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.ClickhouseInstance.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getClickhouseInstance(idOrCode: string, apiKey: string | null = null): Observable<WebProtocol.ClickhouseInstance> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .get(`${this.baseUrl}/clickhouse/${idOrCode}`, options)
            .pipe(
                map(response => WebProtocol.ClickhouseInstance.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateClickhouseInstance(request: WebProtocol.UpdateClickhouseInstanceRequest, idOrCode: string, apiKey: string | null = null): Observable<WebProtocol.ClickhouseInstance> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json', 'content-type': "application/json", 'x-api-key': `${apiKey}`}) };

        return this.http
            .patch(`${this.baseUrl}/clickhouse/${idOrCode}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<WebProtocol.ClickhouseInstanceError>(WebProtocol.ClickhouseInstanceError).fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.ClickhouseInstance.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public deleteClickhouseInstance(idOrCode: string, apiKey: string | null = null): Observable<void> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .delete(`${this.baseUrl}/clickhouse/${idOrCode}`, options)
            .pipe(
                map(response => undefined)
            );
    }

    public getProjects(apiKey: string | null = null): Observable<DataProtocol.Collection<WebProtocol.Project>> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .get(`${this.baseUrl}/projects`, options)
            .pipe(
                map(response => DataProtocol.Collection.instanceJsonSerializer<WebProtocol.Project>(WebProtocol.Project).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createProject(request: WebProtocol.CreateProjectRequest, keepDb: boolean = true, apiKey: string | null = null): Observable<WebProtocol.Project> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json', 'content-type': "application/json", 'x-api-key': `${apiKey}`}) };

        return this.http
            .post(`${this.baseUrl}/projects?keep_db=${keepDb}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<WebProtocol.ProjectError>(WebProtocol.ProjectError).fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.Project.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getProject(idOrCode: string, apiKey: string | null = null): Observable<WebProtocol.Project> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .get(`${this.baseUrl}/projects/${idOrCode}`, options)
            .pipe(
                map(response => WebProtocol.Project.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateProject(request: WebProtocol.UpdateProjectRequest, idOrCode: string, keepDb: boolean = true, apiKey: string | null = null): Observable<WebProtocol.Project> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json', 'content-type': "application/json", 'x-api-key': `${apiKey}`}) };

        return this.http
            .patch(`${this.baseUrl}/projects/${idOrCode}?keep_db=${keepDb}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<WebProtocol.ProjectError>(WebProtocol.ProjectError).fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.Project.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public deleteProject(idOrCode: string, keepDb: boolean = true, apiKey: string | null = null): Observable<void> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .delete(`${this.baseUrl}/projects/${idOrCode}?keep_db=${keepDb}`, options)
            .pipe(
                map(response => undefined)
            );
    }

    public regenerateProjectKey(request: DataProtocol.Empty, idOrCode: string, key: string, apiKey: string | null = null): Observable<WebProtocol.Project> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json', 'content-type': "application/json", 'x-api-key': `${apiKey}`}) };

        return this.http
            .put(`${this.baseUrl}/projects/${idOrCode}/${key}/regenerate`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.Project.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public fetchProjectEvents(idOrCode: string, count: number = 10, apiKey: string | null = null): Observable<Array<Igor.Json.JsonValue>> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .get(`${this.baseUrl}/projects/${idOrCode}/events?count=${count}`, options)
            .pipe(
                map(response => Igor.Json.List(Igor.Json.Json).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public fetchSchemaMigrations(idOrCode: string, orderBy: WebProtocol.SchemaMigrationOrderBy = WebProtocol.SchemaMigrationOrderBy.CreatedAt, orderDir: DataProtocol.OrderDirection = DataProtocol.OrderDirection.Desc, offset: number = 0, limit: number = 10, apiKey: string | null = null): Observable<DataProtocol.CollectionSlice<WebProtocol.SchemaMigration>> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .get(`${this.baseUrl}/projects/${idOrCode}/migrations?order_by=${WebProtocol.SchemaMigrationOrderBy.toJson(orderBy)}&order_dir=${DataProtocol.OrderDirection.toJson(orderDir)}&offset=${offset}&limit=${limit}`, options)
            .pipe(
                map(response => DataProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.SchemaMigration>(WebProtocol.SchemaMigration).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public fetchSchemaMigration(idOrCode: string, migrationId: number, apiKey: string | null = null): Observable<WebProtocol.SchemaMigration> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .get(`${this.baseUrl}/projects/${idOrCode}/migration/${migrationId}`, options)
            .pipe(
                map(response => WebProtocol.SchemaMigration.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getBackupFields(idOrCode: string, orderBy: WebProtocol.BackupFieldsOrderBy = WebProtocol.BackupFieldsOrderBy.Name, orderDir: DataProtocol.OrderDirection = DataProtocol.OrderDirection.Asc, offset: number = 0, limit: number = 10, apiKey: string | null = null): Observable<DataProtocol.CollectionSlice<string>> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .get(`${this.baseUrl}/projects/${idOrCode}/backup_fields?order_by=${WebProtocol.BackupFieldsOrderBy.toJson(orderBy)}&order_dir=${DataProtocol.OrderDirection.toJson(orderDir)}&offset=${offset}&limit=${limit}`, options)
            .pipe(
                map(response => DataProtocol.CollectionSlice.instanceJsonSerializer<string>(Igor.Json.String).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public dropBackupFields(request: Array<string>, idOrCode: string, apiKey: string | null = null): Observable<void> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json', 'x-api-key': `${apiKey}`}) };

        return this.http
            .put(`${this.baseUrl}/projects/${idOrCode}/backup_fields/drop`, Igor.Json.List(Igor.Json.String).toJson(request), options)
            .pipe(
                map(response => undefined)
            );
    }
}
