// Author: Igor compiler
// Compiler version: igorc 2.1.4
// DO NOT EDIT THIS FILE - it is machine generated

import * as Igor from './igor';

export enum DescriptorKind {
    Bool = 1,
    Int = 2,
    Float = 3,
    String = 4,
    Binary = 5,
    List = 6,
    Dict = 7,
    Enum = 8,
    Record = 9,
    Union = 10,
    Key = 11,
    Localized = 12,
    Datetime = 13,
    Json = 14,
    Custom = 15,
    GenericInstance = 16,
    GenericArgument = 17,
}

export namespace DescriptorKind {
    export function toJson(value: DescriptorKind): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): DescriptorKind {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: DescriptorKind): Igor.Json.JsonValue {
        switch (value) {
            case DescriptorKind.Bool: return 'bool';
            case DescriptorKind.Int: return 'int';
            case DescriptorKind.Float: return 'float';
            case DescriptorKind.String: return 'string';
            case DescriptorKind.Binary: return 'binary';
            case DescriptorKind.List: return 'list';
            case DescriptorKind.Dict: return 'dict';
            case DescriptorKind.Enum: return 'enum';
            case DescriptorKind.Record: return 'record';
            case DescriptorKind.Union: return 'union';
            case DescriptorKind.Key: return 'key';
            case DescriptorKind.Localized: return 'localized';
            case DescriptorKind.Datetime: return 'datetime';
            case DescriptorKind.Json: return 'json';
            case DescriptorKind.Custom: return 'custom';
            case DescriptorKind.GenericInstance: return 'generic_instance';
            case DescriptorKind.GenericArgument: return 'generic_argument';
            default: throw new Error(`Invalid DescriptorKind value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): DescriptorKind {
        switch (json) {
            case 'bool': return DescriptorKind.Bool;
            case 'int': return DescriptorKind.Int;
            case 'float': return DescriptorKind.Float;
            case 'string': return DescriptorKind.String;
            case 'binary': return DescriptorKind.Binary;
            case 'list': return DescriptorKind.List;
            case 'dict': return DescriptorKind.Dict;
            case 'enum': return DescriptorKind.Enum;
            case 'record': return DescriptorKind.Record;
            case 'union': return DescriptorKind.Union;
            case 'key': return DescriptorKind.Key;
            case 'localized': return DescriptorKind.Localized;
            case 'datetime': return DescriptorKind.Datetime;
            case 'json': return DescriptorKind.Json;
            case 'custom': return DescriptorKind.Custom;
            case 'generic_instance': return DescriptorKind.GenericInstance;
            case 'generic_argument': return DescriptorKind.GenericArgument;
            default: throw new Error(`Invalid DescriptorKind value: ${json}`);
        }
    }
}

export abstract class Descriptor {
    kind!: DescriptorKind;
    optional: boolean = false;
    help?: string | null = null;
    editorKey?: string | null = null;
    meta?: {[key: string]: Igor.Json.JsonValue} | null = null;

    static fromJson(json: Igor.Json.JsonValue): Descriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const kind = DescriptorKind.fromJson(jsonObject['kind']);
        switch(kind) {
            case DescriptorKind.Bool:
                return BoolDescriptor.fromJson(json);
            case DescriptorKind.Int:
                return IntDescriptor.fromJson(json);
            case DescriptorKind.Float:
                return FloatDescriptor.fromJson(json);
            case DescriptorKind.String:
                return StringDescriptor.fromJson(json);
            case DescriptorKind.Binary:
                return BinaryDescriptor.fromJson(json);
            case DescriptorKind.List:
                return ListDescriptor.fromJson(json);
            case DescriptorKind.Dict:
                return DictDescriptor.fromJson(json);
            case DescriptorKind.Enum:
                return EnumDescriptor.fromJson(json);
            case DescriptorKind.Record:
                return RecordDescriptor.fromJson(json);
            case DescriptorKind.Union:
                return UnionDescriptor.fromJson(json);
            case DescriptorKind.Key:
                return KeyDescriptor.fromJson(json);
            case DescriptorKind.Localized:
                return LocalizedDescriptor.fromJson(json);
            case DescriptorKind.Datetime:
                return DateTimeDescriptor.fromJson(json);
            case DescriptorKind.Json:
                return JsonDescriptor.fromJson(json);
            case DescriptorKind.Custom:
                return CustomDescriptor.fromJson(json);
            case DescriptorKind.GenericInstance:
                return GenericInstanceDescriptor.fromJson(json);
            case DescriptorKind.GenericArgument:
                return GenericArgumentDescriptor.fromJson(json);
            default:
                throw new Error(`Invalid DescriptorKind value: ${kind}`);
        }
    }

    static toJson(value: Descriptor): Igor.Json.JsonValue {
        return value.toJson();
    }

    abstract toJson(): Igor.Json.JsonValue;
}

export class BoolDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Bool;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    default?: boolean | null = null;

    static override fromJson(json: Igor.Json.JsonValue): BoolDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BoolDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.default = ('default' in jsonObject && jsonObject['default'] != null) ? jsonObject['default'] as boolean : null;
        return obj;
    }

    static override toJson(value: BoolDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        if (value.default != null) result['default'] = value.default;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return BoolDescriptor.toJson(this);
    }
}

export enum IntTypeName {
    Int8 = 1,
    Uint8 = 2,
    Int16 = 3,
    Uint16 = 4,
    Int32 = 5,
    Uint32 = 6,
    Int64 = 7,
    Uint64 = 8,
}

export namespace IntTypeName {
    export function toJson(value: IntTypeName): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): IntTypeName {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: IntTypeName): Igor.Json.JsonValue {
        switch (value) {
            case IntTypeName.Int8: return 'int8';
            case IntTypeName.Uint8: return 'uint8';
            case IntTypeName.Int16: return 'int16';
            case IntTypeName.Uint16: return 'uint16';
            case IntTypeName.Int32: return 'int32';
            case IntTypeName.Uint32: return 'uint32';
            case IntTypeName.Int64: return 'int64';
            case IntTypeName.Uint64: return 'uint64';
            default: throw new Error(`Invalid IntTypeName value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): IntTypeName {
        switch (json) {
            case 'int8': return IntTypeName.Int8;
            case 'uint8': return IntTypeName.Uint8;
            case 'int16': return IntTypeName.Int16;
            case 'uint16': return IntTypeName.Uint16;
            case 'int32': return IntTypeName.Int32;
            case 'uint32': return IntTypeName.Uint32;
            case 'int64': return IntTypeName.Int64;
            case 'uint64': return IntTypeName.Uint64;
            default: throw new Error(`Invalid IntTypeName value: ${json}`);
        }
    }
}

export class IntDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Int;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    default?: number | null = null;
    min?: number | null = null;
    max?: number | null = null;
    type?: IntTypeName | null = null;

    static override fromJson(json: Igor.Json.JsonValue): IntDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new IntDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.default = ('default' in jsonObject && jsonObject['default'] != null) ? jsonObject['default'] as number : null;
        obj.min = ('min' in jsonObject && jsonObject['min'] != null) ? jsonObject['min'] as number : null;
        obj.max = ('max' in jsonObject && jsonObject['max'] != null) ? jsonObject['max'] as number : null;
        obj.type = ('type' in jsonObject && jsonObject['type'] != null) ? IntTypeName.fromJson(jsonObject['type']) : null;
        return obj;
    }

    static override toJson(value: IntDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        if (value.default != null) result['default'] = value.default;
        if (value.min != null) result['min'] = value.min;
        if (value.max != null) result['max'] = value.max;
        if (value.type != null) result['type'] = IntTypeName.toJson(value.type);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return IntDescriptor.toJson(this);
    }
}

export enum FloatTypeName {
    Float32 = 1,
    Float64 = 2,
}

export namespace FloatTypeName {
    export function toJson(value: FloatTypeName): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): FloatTypeName {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: FloatTypeName): Igor.Json.JsonValue {
        switch (value) {
            case FloatTypeName.Float32: return 'float32';
            case FloatTypeName.Float64: return 'float64';
            default: throw new Error(`Invalid FloatTypeName value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): FloatTypeName {
        switch (json) {
            case 'float32': return FloatTypeName.Float32;
            case 'float64': return FloatTypeName.Float64;
            default: throw new Error(`Invalid FloatTypeName value: ${json}`);
        }
    }
}

export class FloatDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Float;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    default?: number | null = null;
    min?: number | null = null;
    max?: number | null = null;
    type?: FloatTypeName | null = null;

    static override fromJson(json: Igor.Json.JsonValue): FloatDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new FloatDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.default = ('default' in jsonObject && jsonObject['default'] != null) ? jsonObject['default'] as number : null;
        obj.min = ('min' in jsonObject && jsonObject['min'] != null) ? jsonObject['min'] as number : null;
        obj.max = ('max' in jsonObject && jsonObject['max'] != null) ? jsonObject['max'] as number : null;
        obj.type = ('type' in jsonObject && jsonObject['type'] != null) ? FloatTypeName.fromJson(jsonObject['type']) : null;
        return obj;
    }

    static override toJson(value: FloatDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        if (value.default != null) result['default'] = value.default;
        if (value.min != null) result['min'] = value.min;
        if (value.max != null) result['max'] = value.max;
        if (value.type != null) result['type'] = FloatTypeName.toJson(value.type);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return FloatDescriptor.toJson(this);
    }
}

export class PathOptions {
    root?: string | null = null;
    defaultPath?: string | null = null;
    extension?: string | null = null;
    includeExtension?: boolean | null = null;

    static fromJson(json: Igor.Json.JsonValue): PathOptions {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PathOptions();
        obj.root = ('root' in jsonObject && jsonObject['root'] != null) ? jsonObject['root'] as string : null;
        obj.defaultPath = ('default_path' in jsonObject && jsonObject['default_path'] != null) ? jsonObject['default_path'] as string : null;
        obj.extension = ('extension' in jsonObject && jsonObject['extension'] != null) ? jsonObject['extension'] as string : null;
        obj.includeExtension = ('include_extension' in jsonObject && jsonObject['include_extension'] != null) ? jsonObject['include_extension'] as boolean : null;
        return obj;
    }

    static toJson(value: PathOptions): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.root != null) result['root'] = value.root;
        if (value.defaultPath != null) result['default_path'] = value.defaultPath;
        if (value.extension != null) result['extension'] = value.extension;
        if (value.includeExtension != null) result['include_extension'] = value.includeExtension;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PathOptions.toJson(this);
    }
}

export class StringDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.String;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    default?: string | null = null;
    multiline: boolean = false;
    notEmpty: boolean = false;
    lowCardinality?: boolean | null = null;
    source?: string | null = null;
    path?: PathOptions | null = null;
    syntax?: string | null = null;

    static override fromJson(json: Igor.Json.JsonValue): StringDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new StringDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.default = ('default' in jsonObject && jsonObject['default'] != null) ? jsonObject['default'] as string : null;
        obj.multiline = ('multiline' in jsonObject && jsonObject['multiline'] != null) ? jsonObject['multiline'] as boolean : false;
        obj.notEmpty = ('not_empty' in jsonObject && jsonObject['not_empty'] != null) ? jsonObject['not_empty'] as boolean : false;
        obj.lowCardinality = ('low_cardinality' in jsonObject && jsonObject['low_cardinality'] != null) ? jsonObject['low_cardinality'] as boolean : null;
        obj.source = ('source' in jsonObject && jsonObject['source'] != null) ? jsonObject['source'] as string : null;
        obj.path = ('path' in jsonObject && jsonObject['path'] != null) ? PathOptions.fromJson(jsonObject['path']) : null;
        obj.syntax = ('syntax' in jsonObject && jsonObject['syntax'] != null) ? jsonObject['syntax'] as string : null;
        return obj;
    }

    static override toJson(value: StringDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        if (value.default != null) result['default'] = value.default;
        result['multiline'] = value.multiline;
        result['not_empty'] = value.notEmpty;
        if (value.lowCardinality != null) result['low_cardinality'] = value.lowCardinality;
        if (value.source != null) result['source'] = value.source;
        if (value.path != null) result['path'] = value.path.toJson();
        if (value.syntax != null) result['syntax'] = value.syntax;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return StringDescriptor.toJson(this);
    }
}

export class BinaryDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Binary;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;

    static override fromJson(json: Igor.Json.JsonValue): BinaryDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BinaryDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        return obj;
    }

    static override toJson(value: BinaryDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return BinaryDescriptor.toJson(this);
    }
}

export class ListDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.List;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    element!: Descriptor;
    default?: Igor.Json.JsonValue | null = null;

    static override fromJson(json: Igor.Json.JsonValue): ListDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ListDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.element = Descriptor.fromJson(jsonObject['element']);
        obj.default = ('default' in jsonObject && jsonObject['default'] != null) ? jsonObject['default'] : null;
        return obj;
    }

    static override toJson(value: ListDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        result['element'] = value.element.toJson();
        if (value.default != null) result['default'] = value.default;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return ListDescriptor.toJson(this);
    }
}

export class DictDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Dict;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    key!: Descriptor;
    value!: Descriptor;
    default?: Igor.Json.JsonValue | null = null;

    static override fromJson(json: Igor.Json.JsonValue): DictDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new DictDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.key = Descriptor.fromJson(jsonObject['key']);
        obj.value = Descriptor.fromJson(jsonObject['value']);
        obj.default = ('default' in jsonObject && jsonObject['default'] != null) ? jsonObject['default'] : null;
        return obj;
    }

    static override toJson(value: DictDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        result['key'] = value.key.toJson();
        result['value'] = value.value.toJson();
        if (value.default != null) result['default'] = value.default;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return DictDescriptor.toJson(this);
    }
}

export class EnumDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Enum;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    name!: string;
    default?: string | null = null;

    static override fromJson(json: Igor.Json.JsonValue): EnumDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new EnumDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.name = jsonObject['name'] as string;
        obj.default = ('default' in jsonObject && jsonObject['default'] != null) ? jsonObject['default'] as string : null;
        return obj;
    }

    static override toJson(value: EnumDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        result['name'] = value.name;
        if (value.default != null) result['default'] = value.default;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return EnumDescriptor.toJson(this);
    }
}

export class RecordDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Record;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    name!: string;
    compact: boolean = false;

    static override fromJson(json: Igor.Json.JsonValue): RecordDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new RecordDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.name = jsonObject['name'] as string;
        obj.compact = ('compact' in jsonObject && jsonObject['compact'] != null) ? jsonObject['compact'] as boolean : false;
        return obj;
    }

    static override toJson(value: RecordDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        result['name'] = value.name;
        result['compact'] = value.compact;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return RecordDescriptor.toJson(this);
    }
}

export class UnionDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Union;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    name!: string;
    compact: boolean = false;

    static override fromJson(json: Igor.Json.JsonValue): UnionDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new UnionDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.name = jsonObject['name'] as string;
        obj.compact = ('compact' in jsonObject && jsonObject['compact'] != null) ? jsonObject['compact'] as boolean : false;
        return obj;
    }

    static override toJson(value: UnionDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        result['name'] = value.name;
        result['compact'] = value.compact;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return UnionDescriptor.toJson(this);
    }
}

export class KeyDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Key;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    category?: string | null = null;
    interface?: string | null = null;

    static override fromJson(json: Igor.Json.JsonValue): KeyDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new KeyDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.category = ('category' in jsonObject && jsonObject['category'] != null) ? jsonObject['category'] as string : null;
        obj.interface = ('interface' in jsonObject && jsonObject['interface'] != null) ? jsonObject['interface'] as string : null;
        return obj;
    }

    static override toJson(value: KeyDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        if (value.category != null) result['category'] = value.category;
        if (value.interface != null) result['interface'] = value.interface;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return KeyDescriptor.toJson(this);
    }
}

export class LocalizedDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Localized;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    name!: string;
    multiline: boolean = false;

    static override fromJson(json: Igor.Json.JsonValue): LocalizedDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new LocalizedDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.name = jsonObject['name'] as string;
        obj.multiline = ('multiline' in jsonObject && jsonObject['multiline'] != null) ? jsonObject['multiline'] as boolean : false;
        return obj;
    }

    static override toJson(value: LocalizedDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        result['name'] = value.name;
        result['multiline'] = value.multiline;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return LocalizedDescriptor.toJson(this);
    }
}

export class DateTimeDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Datetime;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;

    static override fromJson(json: Igor.Json.JsonValue): DateTimeDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new DateTimeDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        return obj;
    }

    static override toJson(value: DateTimeDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return DateTimeDescriptor.toJson(this);
    }
}

export class JsonDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Json;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;

    static override fromJson(json: Igor.Json.JsonValue): JsonDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new JsonDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        return obj;
    }

    static override toJson(value: JsonDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return JsonDescriptor.toJson(this);
    }
}

export class CustomDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.Custom;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;

    static override fromJson(json: Igor.Json.JsonValue): CustomDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CustomDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        return obj;
    }

    static override toJson(value: CustomDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return CustomDescriptor.toJson(this);
    }
}

export class GenericInstanceDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.GenericInstance;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    prototype!: string;
    arguments!: Array<Descriptor>;

    static override fromJson(json: Igor.Json.JsonValue): GenericInstanceDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GenericInstanceDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.prototype = jsonObject['prototype'] as string;
        obj.arguments = Igor.Json.List(Descriptor).fromJson(jsonObject['arguments']);
        return obj;
    }

    static override toJson(value: GenericInstanceDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        result['prototype'] = value.prototype;
        result['arguments'] = Igor.Json.List(Descriptor).toJson(value.arguments);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return GenericInstanceDescriptor.toJson(this);
    }
}

export class GenericArgumentDescriptor extends Descriptor {
    override kind: DescriptorKind = DescriptorKind.GenericArgument;
    override optional: boolean = false;
    override help?: string | null = null;
    override editorKey?: string | null = null;
    override meta?: {[key: string]: Igor.Json.JsonValue} | null = null;
    name!: string;

    static override fromJson(json: Igor.Json.JsonValue): GenericArgumentDescriptor {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GenericArgumentDescriptor();
        obj.optional = ('optional' in jsonObject && jsonObject['optional'] != null) ? jsonObject['optional'] as boolean : false;
        obj.help = ('help' in jsonObject && jsonObject['help'] != null) ? jsonObject['help'] as string : null;
        obj.editorKey = ('editor_key' in jsonObject && jsonObject['editor_key'] != null) ? jsonObject['editor_key'] as string : null;
        obj.meta = ('meta' in jsonObject && jsonObject['meta'] != null) ? Igor.Json.Dict(Igor.Json.Json).fromJson(jsonObject['meta']) : null;
        obj.name = jsonObject['name'] as string;
        return obj;
    }

    static override toJson(value: GenericArgumentDescriptor): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = DescriptorKind.toJson(value.kind);
        result['optional'] = value.optional;
        if (value.help != null) result['help'] = value.help;
        if (value.editorKey != null) result['editor_key'] = value.editorKey;
        if (value.meta != null) result['meta'] = Igor.Json.Dict(Igor.Json.Json).toJson(value.meta);
        result['name'] = value.name;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return GenericArgumentDescriptor.toJson(this);
    }
}

export enum CustomTypeKind {
    Record = 1,
    Variant = 2,
    Enum = 3,
    Union = 4,
}

export namespace CustomTypeKind {
    export function toJson(value: CustomTypeKind): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): CustomTypeKind {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: CustomTypeKind): Igor.Json.JsonValue {
        switch (value) {
            case CustomTypeKind.Record: return 'record';
            case CustomTypeKind.Variant: return 'variant';
            case CustomTypeKind.Enum: return 'enum';
            case CustomTypeKind.Union: return 'union';
            default: throw new Error(`Invalid CustomTypeKind value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): CustomTypeKind {
        switch (json) {
            case 'record': return CustomTypeKind.Record;
            case 'variant': return CustomTypeKind.Variant;
            case 'enum': return CustomTypeKind.Enum;
            case 'union': return CustomTypeKind.Union;
            default: throw new Error(`Invalid CustomTypeKind value: ${json}`);
        }
    }
}

export abstract class CustomType {
    kind!: CustomTypeKind;

    static fromJson(json: Igor.Json.JsonValue): CustomType {
        const jsonObject = json as Igor.Json.JsonObject;
        const kind = CustomTypeKind.fromJson(jsonObject['kind']);
        switch(kind) {
            case CustomTypeKind.Record:
                return RecordCustomType.fromJson(json);
            case CustomTypeKind.Variant:
                return VariantCustomType.fromJson(json);
            case CustomTypeKind.Enum:
                return EnumCustomType.fromJson(json);
            case CustomTypeKind.Union:
                return UnionCustomType.fromJson(json);
            default:
                throw new Error(`Invalid CustomTypeKind value: ${kind}`);
        }
    }

    static toJson(value: CustomType): Igor.Json.JsonValue {
        return value.toJson();
    }

    abstract toJson(): Igor.Json.JsonValue;
}

export abstract class StructCustomType extends CustomType {
    override kind!: CustomTypeKind;
    fields!: {[key: string]: Descriptor};
    parent?: string | null = null;
    interfaces!: Array<string>;

    static fromJson(json: Igor.Json.JsonValue): StructCustomType {
        const jsonObject = json as Igor.Json.JsonObject;
        const kind = CustomTypeKind.fromJson(jsonObject['kind']);
        switch(kind) {
            case CustomTypeKind.Record:
                return RecordCustomType.fromJson(json);
            case CustomTypeKind.Variant:
                return VariantCustomType.fromJson(json);
            default:
                throw new Error(`Invalid CustomTypeKind value: ${kind}`);
        }
    }

    static toJson(value: StructCustomType): Igor.Json.JsonValue {
        return value.toJson();
    }

    abstract toJson(): Igor.Json.JsonValue;
}

export class RecordCustomType extends StructCustomType {
    override kind: CustomTypeKind = CustomTypeKind.Record;
    override fields!: {[key: string]: Descriptor};
    override parent?: string | null = null;
    override interfaces!: Array<string>;
    genericArguments?: Array<string> | null = null;
    group?: string | null = null;

    static override fromJson(json: Igor.Json.JsonValue): RecordCustomType {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new RecordCustomType();
        obj.fields = Igor.Json.Dict(Descriptor).fromJson(jsonObject['fields']);
        obj.parent = ('parent' in jsonObject && jsonObject['parent'] != null) ? jsonObject['parent'] as string : null;
        obj.interfaces = Igor.Json.List(Igor.Json.String).fromJson(jsonObject['interfaces']);
        obj.genericArguments = ('generic_arguments' in jsonObject && jsonObject['generic_arguments'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['generic_arguments']) : null;
        obj.group = ('group' in jsonObject && jsonObject['group'] != null) ? jsonObject['group'] as string : null;
        return obj;
    }

    static override toJson(value: RecordCustomType): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = CustomTypeKind.toJson(value.kind);
        result['fields'] = Igor.Json.Dict(Descriptor).toJson(value.fields);
        if (value.parent != null) result['parent'] = value.parent;
        result['interfaces'] = Igor.Json.List(Igor.Json.String).toJson(value.interfaces);
        if (value.genericArguments != null) result['generic_arguments'] = Igor.Json.List(Igor.Json.String).toJson(value.genericArguments);
        if (value.group != null) result['group'] = value.group;
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return RecordCustomType.toJson(this);
    }
}

export class VariantCustomType extends StructCustomType {
    override kind: CustomTypeKind = CustomTypeKind.Variant;
    override fields!: {[key: string]: Descriptor};
    override parent?: string | null = null;
    override interfaces!: Array<string>;
    tag!: string;
    children!: {[key: string]: string};

    static override fromJson(json: Igor.Json.JsonValue): VariantCustomType {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new VariantCustomType();
        obj.fields = Igor.Json.Dict(Descriptor).fromJson(jsonObject['fields']);
        obj.parent = ('parent' in jsonObject && jsonObject['parent'] != null) ? jsonObject['parent'] as string : null;
        obj.interfaces = Igor.Json.List(Igor.Json.String).fromJson(jsonObject['interfaces']);
        obj.tag = jsonObject['tag'] as string;
        obj.children = Igor.Json.Dict(Igor.Json.String).fromJson(jsonObject['children']);
        return obj;
    }

    static override toJson(value: VariantCustomType): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = CustomTypeKind.toJson(value.kind);
        result['fields'] = Igor.Json.Dict(Descriptor).toJson(value.fields);
        if (value.parent != null) result['parent'] = value.parent;
        result['interfaces'] = Igor.Json.List(Igor.Json.String).toJson(value.interfaces);
        result['tag'] = value.tag;
        result['children'] = Igor.Json.Dict(Igor.Json.String).toJson(value.children);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return VariantCustomType.toJson(this);
    }
}

export class EnumCustomType extends CustomType {
    override kind: CustomTypeKind = CustomTypeKind.Enum;
    values!: Array<string>;

    static override fromJson(json: Igor.Json.JsonValue): EnumCustomType {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new EnumCustomType();
        obj.values = Igor.Json.List(Igor.Json.String).fromJson(jsonObject['values']);
        return obj;
    }

    static override toJson(value: EnumCustomType): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = CustomTypeKind.toJson(value.kind);
        result['values'] = Igor.Json.List(Igor.Json.String).toJson(value.values);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return EnumCustomType.toJson(this);
    }
}

export class UnionCustomType extends CustomType {
    override kind: CustomTypeKind = CustomTypeKind.Union;
    clauses!: {[key: string]: Descriptor | null};
    genericArguments?: Array<string> | null = null;

    static override fromJson(json: Igor.Json.JsonValue): UnionCustomType {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new UnionCustomType();
        obj.clauses = Igor.Json.Dict(Igor.Json.Optional(Descriptor)).fromJson(jsonObject['clauses']);
        obj.genericArguments = ('generic_arguments' in jsonObject && jsonObject['generic_arguments'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['generic_arguments']) : null;
        return obj;
    }

    static override toJson(value: UnionCustomType): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['kind'] = CustomTypeKind.toJson(value.kind);
        result['clauses'] = Igor.Json.Dict(Igor.Json.Optional(Descriptor)).toJson(value.clauses);
        if (value.genericArguments != null) result['generic_arguments'] = Igor.Json.List(Igor.Json.String).toJson(value.genericArguments);
        return result;
    }

    override toJson(): Igor.Json.JsonValue {
        return UnionCustomType.toJson(this);
    }
}

export class Schema {
    customTypes!: {[key: string]: CustomType};
    documentType!: string;
    version: string = "1.0";

    static fromJson(json: Igor.Json.JsonValue): Schema {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Schema();
        obj.customTypes = Igor.Json.Dict(CustomType).fromJson(jsonObject['custom_types']);
        obj.documentType = jsonObject['document_type'] as string;
        obj.version = ('version' in jsonObject && jsonObject['version'] != null) ? jsonObject['version'] as string : "1.0";
        return obj;
    }

    static toJson(value: Schema): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['custom_types'] = Igor.Json.Dict(CustomType).toJson(value.customTypes);
        result['document_type'] = value.documentType;
        result['version'] = value.version;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return Schema.toJson(this);
    }
}
