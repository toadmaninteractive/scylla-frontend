// Author: Igor compiler
// Compiler version: igorc 2.1.4
// DO NOT EDIT THIS FILE - it is machine generated

import * as Igor from './igor';
import * as TypesProtocol from './types';

/**
 * Authentication
 */
export interface IUserData {
    role: string;
    userId: string;
    username: string;
}

export class LoginRequest {
    username!: string;
    password!: string;

    static fromJson(json: Igor.Json.JsonValue): LoginRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new LoginRequest();
        obj.username = jsonObject['username'] as string;
        obj.password = jsonObject['password'] as string;
        return obj;
    }

    static toJson(value: LoginRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['username'] = value.username;
        result['password'] = value.password;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return LoginRequest.toJson(this);
    }
}

export class LoginResponse implements IUserData {
    role!: string;
    userId!: string;
    username!: string;
    sessionId!: string;

    static fromJson(json: Igor.Json.JsonValue): LoginResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new LoginResponse();
        obj.role = jsonObject['role'] as string;
        obj.userId = jsonObject['user_id'] as string;
        obj.username = jsonObject['username'] as string;
        obj.sessionId = jsonObject['session_id'] as string;
        return obj;
    }

    static toJson(value: LoginResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['role'] = value.role;
        result['user_id'] = value.userId;
        result['username'] = value.username;
        result['session_id'] = value.sessionId;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return LoginResponse.toJson(this);
    }
}

export enum LoginError {
    /** Invalid username or password */
    InvalidUserOrPassword = 1,
}

export namespace LoginError {
    export function toJson(value: LoginError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): LoginError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: LoginError): Igor.Json.JsonValue {
        switch (value) {
            case LoginError.InvalidUserOrPassword: return 'invalid_user_or_password';
            default: throw new Error(`Invalid LoginError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): LoginError {
        switch (json) {
            case 'invalid_user_or_password': return LoginError.InvalidUserOrPassword;
            default: throw new Error(`Invalid LoginError value: ${json}`);
        }
    }
}

export class UserProfile implements IUserData {
    role!: string;
    userId!: string;
    username!: string;

    static fromJson(json: Igor.Json.JsonValue): UserProfile {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new UserProfile();
        obj.role = jsonObject['role'] as string;
        obj.userId = jsonObject['user_id'] as string;
        obj.username = jsonObject['username'] as string;
        return obj;
    }

    static toJson(value: UserProfile): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['role'] = value.role;
        result['user_id'] = value.userId;
        result['username'] = value.username;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return UserProfile.toJson(this);
    }
}

/**
 * ClickHouse instances
 */
export class ClickhouseInstance {
    id!: number;
    code!: string;
    name!: string;
    uri!: string;
    username!: string;
    password!: string;
    rev!: number;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): ClickhouseInstance {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClickhouseInstance();
        obj.id = jsonObject['id'] as number;
        obj.code = jsonObject['code'] as string;
        obj.name = jsonObject['name'] as string;
        obj.uri = jsonObject['uri'] as string;
        obj.username = jsonObject['username'] as string;
        obj.password = jsonObject['password'] as string;
        obj.rev = jsonObject['rev'] as number;
        obj.createdAt = Igor.Json.DateTimeSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateTimeSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: ClickhouseInstance): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['code'] = value.code;
        result['name'] = value.name;
        result['uri'] = value.uri;
        result['username'] = value.username;
        result['password'] = value.password;
        result['rev'] = value.rev;
        result['created_at'] = Igor.Json.DateTimeSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateTimeSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClickhouseInstance.toJson(this);
    }
}

export class CreateClickhouseInstanceRequest {
    code!: string;
    name!: string;
    uri!: string;
    username!: string;
    password!: string;

    static fromJson(json: Igor.Json.JsonValue): CreateClickhouseInstanceRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CreateClickhouseInstanceRequest();
        obj.code = jsonObject['code'] as string;
        obj.name = jsonObject['name'] as string;
        obj.uri = jsonObject['uri'] as string;
        obj.username = jsonObject['username'] as string;
        obj.password = jsonObject['password'] as string;
        return obj;
    }

    static toJson(value: CreateClickhouseInstanceRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['code'] = value.code;
        result['name'] = value.name;
        result['uri'] = value.uri;
        result['username'] = value.username;
        result['password'] = value.password;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return CreateClickhouseInstanceRequest.toJson(this);
    }
}

export class UpdateClickhouseInstanceRequest {
    code!: string;
    name!: string;
    uri!: string;
    username!: string;
    password!: string;

    static fromJson(json: Igor.Json.JsonValue): UpdateClickhouseInstanceRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new UpdateClickhouseInstanceRequest();
        if (jsonObject['code'] !== undefined) obj.code = jsonObject['code'] as string;
        if (jsonObject['name'] !== undefined) obj.name = jsonObject['name'] as string;
        if (jsonObject['uri'] !== undefined) obj.uri = jsonObject['uri'] as string;
        if (jsonObject['username'] !== undefined) obj.username = jsonObject['username'] as string;
        if (jsonObject['password'] !== undefined) obj.password = jsonObject['password'] as string;
        return obj;
    }

    static toJson(value: UpdateClickhouseInstanceRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.code !== undefined) result['code'] = value.code;
        if (value.name !== undefined) result['name'] = value.name;
        if (value.uri !== undefined) result['uri'] = value.uri;
        if (value.username !== undefined) result['username'] = value.username;
        if (value.password !== undefined) result['password'] = value.password;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return UpdateClickhouseInstanceRequest.toJson(this);
    }
}

export enum ClickhouseInstanceError {
    InvalidCode = 1,
    InvalidName = 2,
    InvalidUri = 3,
    InvalidUsername = 4,
    InvalidPassword = 5,
    CodeAlreadyExists = 6,
    NameAlreadyExists = 7,
}

export namespace ClickhouseInstanceError {
    export function toJson(value: ClickhouseInstanceError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ClickhouseInstanceError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ClickhouseInstanceError): Igor.Json.JsonValue {
        switch (value) {
            case ClickhouseInstanceError.InvalidCode: return 'invalid_code';
            case ClickhouseInstanceError.InvalidName: return 'invalid_name';
            case ClickhouseInstanceError.InvalidUri: return 'invalid_uri';
            case ClickhouseInstanceError.InvalidUsername: return 'invalid_username';
            case ClickhouseInstanceError.InvalidPassword: return 'invalid_password';
            case ClickhouseInstanceError.CodeAlreadyExists: return 'code_already_exists';
            case ClickhouseInstanceError.NameAlreadyExists: return 'name_already_exists';
            default: throw new Error(`Invalid ClickhouseInstanceError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ClickhouseInstanceError {
        switch (json) {
            case 'invalid_code': return ClickhouseInstanceError.InvalidCode;
            case 'invalid_name': return ClickhouseInstanceError.InvalidName;
            case 'invalid_uri': return ClickhouseInstanceError.InvalidUri;
            case 'invalid_username': return ClickhouseInstanceError.InvalidUsername;
            case 'invalid_password': return ClickhouseInstanceError.InvalidPassword;
            case 'code_already_exists': return ClickhouseInstanceError.CodeAlreadyExists;
            case 'name_already_exists': return ClickhouseInstanceError.NameAlreadyExists;
            default: throw new Error(`Invalid ClickhouseInstanceError value: ${json}`);
        }
    }
}

/**
 * Projects
 */
export enum ProjectEventValidation {
    Strict = 1,
    None = 2,
    Warn = 3,
}

export namespace ProjectEventValidation {
    export function toJson(value: ProjectEventValidation): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ProjectEventValidation {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ProjectEventValidation): Igor.Json.JsonValue {
        switch (value) {
            case ProjectEventValidation.Strict: return 'strict';
            case ProjectEventValidation.None: return 'none';
            case ProjectEventValidation.Warn: return 'warn';
            default: throw new Error(`Invalid ProjectEventValidation value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ProjectEventValidation {
        switch (json) {
            case 'strict': return ProjectEventValidation.Strict;
            case 'none': return ProjectEventValidation.None;
            case 'warn': return ProjectEventValidation.Warn;
            default: throw new Error(`Invalid ProjectEventValidation value: ${json}`);
        }
    }
}

export class Project {
    id!: number;
    code!: string;
    name!: string;
    clickhouseInstanceId!: number;
    clickhouseCode!: string;
    clickhouseName!: string;
    clickhouseDb!: string;
    keySu!: string;
    keyRw!: string;
    description?: string | null = null;
    schema: string = "{}";
    rev!: number;
    eventValidation!: ProjectEventValidation;
    preserveDbColumns!: boolean;
    backupMode!: boolean;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): Project {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Project();
        obj.id = jsonObject['id'] as number;
        obj.code = jsonObject['code'] as string;
        obj.name = jsonObject['name'] as string;
        obj.clickhouseInstanceId = jsonObject['clickhouse_instance_id'] as number;
        obj.clickhouseCode = jsonObject['clickhouse_code'] as string;
        obj.clickhouseName = jsonObject['clickhouse_name'] as string;
        obj.clickhouseDb = jsonObject['clickhouse_db'] as string;
        obj.keySu = jsonObject['key_su'] as string;
        obj.keyRw = jsonObject['key_rw'] as string;
        obj.description = ('description' in jsonObject && jsonObject['description'] != null) ? jsonObject['description'] as string : null;
        obj.schema = ('schema' in jsonObject && jsonObject['schema'] != null) ? jsonObject['schema'] as string : "{}";
        obj.rev = jsonObject['rev'] as number;
        obj.eventValidation = ProjectEventValidation.fromJson(jsonObject['event_validation']);
        obj.preserveDbColumns = jsonObject['preserve_db_columns'] as boolean;
        obj.backupMode = jsonObject['backup_mode'] as boolean;
        obj.createdAt = Igor.Json.DateTimeSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateTimeSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: Project): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['code'] = value.code;
        result['name'] = value.name;
        result['clickhouse_instance_id'] = value.clickhouseInstanceId;
        result['clickhouse_code'] = value.clickhouseCode;
        result['clickhouse_name'] = value.clickhouseName;
        result['clickhouse_db'] = value.clickhouseDb;
        result['key_su'] = value.keySu;
        result['key_rw'] = value.keyRw;
        if (value.description != null) result['description'] = value.description;
        result['schema'] = value.schema;
        result['rev'] = value.rev;
        result['event_validation'] = ProjectEventValidation.toJson(value.eventValidation);
        result['preserve_db_columns'] = value.preserveDbColumns;
        result['backup_mode'] = value.backupMode;
        result['created_at'] = Igor.Json.DateTimeSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateTimeSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return Project.toJson(this);
    }
}

export class CreateProjectRequest {
    code!: string;
    name!: string;
    clickhouseInstanceId!: number;
    clickhouseDb!: string;
    description?: string | null = null;
    eventValidation: ProjectEventValidation = ProjectEventValidation.Strict;
    preserveDbColumns: boolean = false;
    backupMode: boolean = false;

    static fromJson(json: Igor.Json.JsonValue): CreateProjectRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CreateProjectRequest();
        obj.code = jsonObject['code'] as string;
        obj.name = jsonObject['name'] as string;
        obj.clickhouseInstanceId = jsonObject['clickhouse_instance_id'] as number;
        obj.clickhouseDb = jsonObject['clickhouse_db'] as string;
        obj.description = ('description' in jsonObject && jsonObject['description'] != null) ? jsonObject['description'] as string : null;
        obj.eventValidation = ('event_validation' in jsonObject && jsonObject['event_validation'] != null) ? ProjectEventValidation.fromJson(jsonObject['event_validation']) : ProjectEventValidation.Strict;
        obj.preserveDbColumns = ('preserve_db_columns' in jsonObject && jsonObject['preserve_db_columns'] != null) ? jsonObject['preserve_db_columns'] as boolean : false;
        obj.backupMode = ('backup_mode' in jsonObject && jsonObject['backup_mode'] != null) ? jsonObject['backup_mode'] as boolean : false;
        return obj;
    }

    static toJson(value: CreateProjectRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['code'] = value.code;
        result['name'] = value.name;
        result['clickhouse_instance_id'] = value.clickhouseInstanceId;
        result['clickhouse_db'] = value.clickhouseDb;
        if (value.description != null) result['description'] = value.description;
        result['event_validation'] = ProjectEventValidation.toJson(value.eventValidation);
        result['preserve_db_columns'] = value.preserveDbColumns;
        result['backup_mode'] = value.backupMode;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return CreateProjectRequest.toJson(this);
    }
}

export class UpdateProjectRequest {
    code!: string;
    name!: string;
    clickhouseInstanceId!: number;
    clickhouseDb!: string;
    description!: string;
    eventValidation!: ProjectEventValidation;
    preserveDbColumns!: boolean;
    backupMode!: boolean;

    static fromJson(json: Igor.Json.JsonValue): UpdateProjectRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new UpdateProjectRequest();
        if (jsonObject['code'] !== undefined) obj.code = jsonObject['code'] as string;
        if (jsonObject['name'] !== undefined) obj.name = jsonObject['name'] as string;
        if (jsonObject['clickhouse_instance_id'] !== undefined) obj.clickhouseInstanceId = jsonObject['clickhouse_instance_id'] as number;
        if (jsonObject['clickhouse_db'] !== undefined) obj.clickhouseDb = jsonObject['clickhouse_db'] as string;
        if (jsonObject['description'] !== undefined) obj.description = jsonObject['description'] as string;
        if (jsonObject['event_validation'] !== undefined) obj.eventValidation = ProjectEventValidation.fromJson(jsonObject['event_validation']);
        if (jsonObject['preserve_db_columns'] !== undefined) obj.preserveDbColumns = jsonObject['preserve_db_columns'] as boolean;
        if (jsonObject['backup_mode'] !== undefined) obj.backupMode = jsonObject['backup_mode'] as boolean;
        return obj;
    }

    static toJson(value: UpdateProjectRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.code !== undefined) result['code'] = value.code;
        if (value.name !== undefined) result['name'] = value.name;
        if (value.clickhouseInstanceId !== undefined) result['clickhouse_instance_id'] = value.clickhouseInstanceId;
        if (value.clickhouseDb !== undefined) result['clickhouse_db'] = value.clickhouseDb;
        if (value.description !== undefined) result['description'] = value.description;
        if (value.eventValidation !== undefined) result['event_validation'] = ProjectEventValidation.toJson(value.eventValidation);
        if (value.preserveDbColumns !== undefined) result['preserve_db_columns'] = value.preserveDbColumns;
        if (value.backupMode !== undefined) result['backup_mode'] = value.backupMode;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return UpdateProjectRequest.toJson(this);
    }
}

export enum ProjectError {
    InvalidCode = 1,
    InvalidName = 2,
    InvalidClickhouseInstanceId = 3,
    InvalidClickhouseDb = 4,
    InvalidDescription = 5,
    ClickhouseInstanceNotExists = 6,
    CodeAlreadyExists = 7,
    NameAlreadyExists = 8,
}

export namespace ProjectError {
    export function toJson(value: ProjectError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ProjectError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ProjectError): Igor.Json.JsonValue {
        switch (value) {
            case ProjectError.InvalidCode: return 'invalid_code';
            case ProjectError.InvalidName: return 'invalid_name';
            case ProjectError.InvalidClickhouseInstanceId: return 'invalid_clickhouse_instance_id';
            case ProjectError.InvalidClickhouseDb: return 'invalid_clickhouse_db';
            case ProjectError.InvalidDescription: return 'invalid_description';
            case ProjectError.ClickhouseInstanceNotExists: return 'clickhouse_instance_not_exists';
            case ProjectError.CodeAlreadyExists: return 'code_already_exists';
            case ProjectError.NameAlreadyExists: return 'name_already_exists';
            default: throw new Error(`Invalid ProjectError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ProjectError {
        switch (json) {
            case 'invalid_code': return ProjectError.InvalidCode;
            case 'invalid_name': return ProjectError.InvalidName;
            case 'invalid_clickhouse_instance_id': return ProjectError.InvalidClickhouseInstanceId;
            case 'invalid_clickhouse_db': return ProjectError.InvalidClickhouseDb;
            case 'invalid_description': return ProjectError.InvalidDescription;
            case 'clickhouse_instance_not_exists': return ProjectError.ClickhouseInstanceNotExists;
            case 'code_already_exists': return ProjectError.CodeAlreadyExists;
            case 'name_already_exists': return ProjectError.NameAlreadyExists;
            default: throw new Error(`Invalid ProjectError value: ${json}`);
        }
    }
}

export class SchemaMigration {
    id!: number;
    projectId!: number;
    projectCode!: string;
    previousSchema?: string | null = null;
    schema!: string;
    schemaDiff?: string | null = null;
    createdAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): SchemaMigration {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new SchemaMigration();
        obj.id = jsonObject['id'] as number;
        obj.projectId = jsonObject['project_id'] as number;
        obj.projectCode = jsonObject['project_code'] as string;
        obj.previousSchema = ('previous_schema' in jsonObject && jsonObject['previous_schema'] != null) ? jsonObject['previous_schema'] as string : null;
        obj.schema = jsonObject['schema'] as string;
        obj.schemaDiff = ('schema_diff' in jsonObject && jsonObject['schema_diff'] != null) ? jsonObject['schema_diff'] as string : null;
        obj.createdAt = Igor.Json.DateTimeSerializer.fromJson(jsonObject['created_at']);
        return obj;
    }

    static toJson(value: SchemaMigration): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['project_id'] = value.projectId;
        result['project_code'] = value.projectCode;
        if (value.previousSchema != null) result['previous_schema'] = value.previousSchema;
        result['schema'] = value.schema;
        if (value.schemaDiff != null) result['schema_diff'] = value.schemaDiff;
        result['created_at'] = Igor.Json.DateTimeSerializer.toJson(value.createdAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return SchemaMigration.toJson(this);
    }
}

/**
 * Customer related items sort fields
 */
export enum SchemaMigrationOrderBy {
    Id = 1,
    CreatedAt = 2,
}

export namespace SchemaMigrationOrderBy {
    export function toJson(value: SchemaMigrationOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): SchemaMigrationOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: SchemaMigrationOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case SchemaMigrationOrderBy.Id: return 'id';
            case SchemaMigrationOrderBy.CreatedAt: return 'created_at';
            default: throw new Error(`Invalid SchemaMigrationOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): SchemaMigrationOrderBy {
        switch (json) {
            case 'id': return SchemaMigrationOrderBy.Id;
            case 'created_at': return SchemaMigrationOrderBy.CreatedAt;
            default: throw new Error(`Invalid SchemaMigrationOrderBy value: ${json}`);
        }
    }
}

/**
 * Backup columns sort fields
 */
export enum BackupFieldsOrderBy {
    Name = 1,
    FieldName = 2,
    Migration = 3,
}

export namespace BackupFieldsOrderBy {
    export function toJson(value: BackupFieldsOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): BackupFieldsOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: BackupFieldsOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case BackupFieldsOrderBy.Name: return 'name';
            case BackupFieldsOrderBy.FieldName: return 'field_name';
            case BackupFieldsOrderBy.Migration: return 'migration';
            default: throw new Error(`Invalid BackupFieldsOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): BackupFieldsOrderBy {
        switch (json) {
            case 'name': return BackupFieldsOrderBy.Name;
            case 'field_name': return BackupFieldsOrderBy.FieldName;
            case 'migration': return BackupFieldsOrderBy.Migration;
            default: throw new Error(`Invalid BackupFieldsOrderBy value: ${json}`);
        }
    }
}
