// Author: Igor compiler
// Compiler version: igorc 2.1.4
// DO NOT EDIT THIS FILE - it is machine generated

import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import * as Igor from './igor';
import * as IngestProtocol from './ingest';
import * as DataProtocol from './data';
import * as IgorSchema from './schema';

@Injectable({
    providedIn: 'root',
})
export class ScyllaIngestionService {
    public baseUrl = 'https://ingest.yourcompany.com/ingest';

    constructor(private http: HttpClient) { }

    public sendEvents(request: IngestProtocol.Envelope, projectIdOrCode: string, apiKey: string | null = null): Observable<IngestProtocol.IngestorResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json', 'content-type': "application/json", 'x-api-key': `${apiKey}`}) };

        return this.http
            .post(`${this.baseUrl}/${projectIdOrCode}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<IngestProtocol.IngestError>(IngestProtocol.IngestError).fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => IngestProtocol.IngestorResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getSchema(projectIdOrCode: string, apiKey: string | null = null): Observable<IngestProtocol.OldSchemaResponse> {
        const options = { headers: new HttpHeaders({'x-api-key': `${apiKey}`}) };

        return this.http
            .get(`${this.baseUrl}/${projectIdOrCode}/schema`, options)
            .pipe(
                map(response => IngestProtocol.OldSchemaResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateSchema(request: IgorSchema.Schema, projectIdOrCode: string, force: boolean = false, apiKey: string | null = null): Observable<void> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json', 'content-type': "application/json", 'x-api-key': `${apiKey}`}) };

        return this.http
            .put(`${this.baseUrl}/${projectIdOrCode}/schema?force=${force}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 400: return throwError(DataProtocol.BadRequestError.instanceJsonSerializer<IngestProtocol.SchemaError>(IngestProtocol.SchemaError).fromJson(response.error));
                            case 409: return throwError(DataProtocol.ConflictError.instanceJsonSerializer<IngestProtocol.SchemaConflictError>(IngestProtocol.SchemaConflictError).fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => undefined)
            );
    }
}
