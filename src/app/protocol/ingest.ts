// Author: Igor compiler
// Compiler version: igorc 2.1.4
// DO NOT EDIT THIS FILE - it is machine generated

import * as Igor from './igor';

export class Envelope {
    events!: Array<Igor.Json.JsonValue>;

    static fromJson(json: Igor.Json.JsonValue): Envelope {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Envelope();
        obj.events = Igor.Json.List(Igor.Json.Json).fromJson(jsonObject['events']);
        return obj;
    }

    static toJson(value: Envelope): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['events'] = Igor.Json.List(Igor.Json.Json).toJson(value.events);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return Envelope.toJson(this);
    }
}

export class IngestorResponse {
    ingestedCount!: number;
    errors?: Array<Igor.Json.JsonValue> | null = null;

    static fromJson(json: Igor.Json.JsonValue): IngestorResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new IngestorResponse();
        obj.ingestedCount = jsonObject['ingested_count'] as number;
        obj.errors = ('errors' in jsonObject && jsonObject['errors'] != null) ? Igor.Json.List(Igor.Json.Json).fromJson(jsonObject['errors']) : null;
        return obj;
    }

    static toJson(value: IngestorResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['ingested_count'] = value.ingestedCount;
        if (value.errors != null) result['errors'] = Igor.Json.List(Igor.Json.Json).toJson(value.errors);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return IngestorResponse.toJson(this);
    }
}

export enum IngestError {
    InvalidSchema = 1,
    InvalidEvent = 2,
    InvalidEventTag = 3,
    UnknownEventTag = 4,
}

export namespace IngestError {
    export function toJson(value: IngestError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): IngestError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: IngestError): Igor.Json.JsonValue {
        switch (value) {
            case IngestError.InvalidSchema: return 'invalid_schema';
            case IngestError.InvalidEvent: return 'invalid_event';
            case IngestError.InvalidEventTag: return 'invalid_event_tag';
            case IngestError.UnknownEventTag: return 'unknown_event_tag';
            default: throw new Error(`Invalid IngestError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): IngestError {
        switch (json) {
            case 'invalid_schema': return IngestError.InvalidSchema;
            case 'invalid_event': return IngestError.InvalidEvent;
            case 'invalid_event_tag': return IngestError.InvalidEventTag;
            case 'unknown_event_tag': return IngestError.UnknownEventTag;
            default: throw new Error(`Invalid IngestError value: ${json}`);
        }
    }
}

export enum SchemaError {
    ClashingType = 1,
    UnknownType = 2,
    InvalidName = 3,
    InvalidTypeDefinition = 4,
    UpdateFailed = 5,
}

export namespace SchemaError {
    export function toJson(value: SchemaError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): SchemaError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: SchemaError): Igor.Json.JsonValue {
        switch (value) {
            case SchemaError.ClashingType: return 'clashing_type';
            case SchemaError.UnknownType: return 'unknown_type';
            case SchemaError.InvalidName: return 'invalid_name';
            case SchemaError.InvalidTypeDefinition: return 'invalid_type_definition';
            case SchemaError.UpdateFailed: return 'update_failed';
            default: throw new Error(`Invalid SchemaError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): SchemaError {
        switch (json) {
            case 'clashing_type': return SchemaError.ClashingType;
            case 'unknown_type': return SchemaError.UnknownType;
            case 'invalid_name': return SchemaError.InvalidName;
            case 'invalid_type_definition': return SchemaError.InvalidTypeDefinition;
            case 'update_failed': return SchemaError.UpdateFailed;
            default: throw new Error(`Invalid SchemaError value: ${json}`);
        }
    }
}

export enum SchemaConflictError {
    DangerousAction = 1,
}

export namespace SchemaConflictError {
    export function toJson(value: SchemaConflictError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): SchemaConflictError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: SchemaConflictError): Igor.Json.JsonValue {
        switch (value) {
            case SchemaConflictError.DangerousAction: return 'dangerous_action';
            default: throw new Error(`Invalid SchemaConflictError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): SchemaConflictError {
        switch (json) {
            case 'dangerous_action': return SchemaConflictError.DangerousAction;
            default: throw new Error(`Invalid SchemaConflictError value: ${json}`);
        }
    }
}

export class OldSchemaResponse {
    schema!: {[key: string]: string};
    order!: Array<string>;
    orderBy!: string;

    static fromJson(json: Igor.Json.JsonValue): OldSchemaResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new OldSchemaResponse();
        obj.schema = Igor.Json.Dict(Igor.Json.String).fromJson(jsonObject['schema']);
        obj.order = Igor.Json.List(Igor.Json.String).fromJson(jsonObject['order']);
        obj.orderBy = jsonObject['order_by'] as string;
        return obj;
    }

    static toJson(value: OldSchemaResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['schema'] = Igor.Json.Dict(Igor.Json.String).toJson(value.schema);
        result['order'] = Igor.Json.List(Igor.Json.String).toJson(value.order);
        result['order_by'] = value.orderBy;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return OldSchemaResponse.toJson(this);
    }
}
