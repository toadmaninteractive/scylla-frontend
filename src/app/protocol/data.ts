// Author: Igor compiler
// Compiler version: igorc 2.1.4
// DO NOT EDIT THIS FILE - it is machine generated

import * as Igor from './igor';

export enum OrderDirection {
    Asc = 1,
    Desc = 2,
}

export namespace OrderDirection {
    export function toJson(value: OrderDirection): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): OrderDirection {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: OrderDirection): Igor.Json.JsonValue {
        switch (value) {
            case OrderDirection.Asc: return 'asc';
            case OrderDirection.Desc: return 'desc';
            default: throw new Error(`Invalid OrderDirection value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): OrderDirection {
        switch (json) {
            case 'asc': return OrderDirection.Asc;
            case 'desc': return OrderDirection.Desc;
            default: throw new Error(`Invalid OrderDirection value: ${json}`);
        }
    }

    export function getDescription(value: OrderDirection): string {
        switch (value) {
            case OrderDirection.Asc: return '';
            case OrderDirection.Desc: return '';
            default: return '';
        }
    }
}

export class Collection<T> {
    items!: Array<T>;

    static fromJson<T>(json: Igor.Json.JsonValue, t: Igor.Json.IJsonSerializer<T>): Collection<T> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Collection<T>();
        obj.items = Igor.Json.List(t).fromJson(jsonObject['items']);
        return obj;
    }

    static toJson<T>(value: Collection<T>, t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['items'] = Igor.Json.List(t).toJson(value.items);
        return result;
    }

    toJson(t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        return Collection.toJson<T>(this, t);
    }

    static instanceJsonSerializer<T>(t: Igor.Json.IJsonSerializer<T>): Igor.Json.IJsonSerializer<Collection<T>> {
        return {
            toJson(value: Collection<T>): Igor.Json.JsonValue {
                return value.toJson(t);
            },

            fromJson(json: Igor.Json.JsonValue): Collection<T> {
                return Collection.fromJson<T>(json, t);
            }
        };
    }
}

export class CollectionSlice<T> {
    total!: number;
    items!: Array<T>;

    static fromJson<T>(json: Igor.Json.JsonValue, t: Igor.Json.IJsonSerializer<T>): CollectionSlice<T> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CollectionSlice<T>();
        obj.total = jsonObject['total'] as number;
        obj.items = Igor.Json.List(t).fromJson(jsonObject['items']);
        return obj;
    }

    static toJson<T>(value: CollectionSlice<T>, t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['total'] = value.total;
        result['items'] = Igor.Json.List(t).toJson(value.items);
        return result;
    }

    toJson(t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        return CollectionSlice.toJson<T>(this, t);
    }

    static instanceJsonSerializer<T>(t: Igor.Json.IJsonSerializer<T>): Igor.Json.IJsonSerializer<CollectionSlice<T>> {
        return {
            toJson(value: CollectionSlice<T>): Igor.Json.JsonValue {
                return value.toJson(t);
            },

            fromJson(json: Igor.Json.JsonValue): CollectionSlice<T> {
                return CollectionSlice.fromJson<T>(json, t);
            }
        };
    }
}

export class Empty {
    static fromJson(json: Igor.Json.JsonValue): Empty {
        const obj = new Empty();
        return obj;
    }

    static toJson(value: Empty): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return Empty.toJson(this);
    }
}

export class GenericResponse {
    result!: boolean;

    static fromJson(json: Igor.Json.JsonValue): GenericResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GenericResponse();
        obj.result = jsonObject['result'] as boolean;
        return obj;
    }

    static toJson(value: GenericResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GenericResponse.toJson(this);
    }
}

/**
 * HTTP errors
 */
export interface HttpError {
    message: string;
    logId?: string | null;
}

export class BadRequestError<TError> extends Error implements HttpError {
    message: string = "Could not process the request due to client error";
    logId?: string | null = null;
    error?: TError | null = null;
    details?: Igor.Json.JsonValue | null = null;

    constructor() {
        super('BadRequestError');
        Object.setPrototypeOf(this, new.target.prototype);
    }

    static fromJson<TError>(json: Igor.Json.JsonValue, tError: Igor.Json.IJsonSerializer<TError>): BadRequestError<TError> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BadRequestError<TError>();
        obj.message = ('message' in jsonObject && jsonObject['message'] != null) ? jsonObject['message'] as string : "Could not process the request due to client error";
        obj.logId = ('log_id' in jsonObject && jsonObject['log_id'] != null) ? jsonObject['log_id'] as string : null;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? tError.fromJson(jsonObject['error']) : null;
        obj.details = ('details' in jsonObject && jsonObject['details'] != null) ? jsonObject['details'] : null;
        return obj;
    }

    static toJson<TError>(value: BadRequestError<TError>, tError: Igor.Json.IJsonSerializer<TError>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['message'] = value.message;
        if (value.logId != null) result['log_id'] = value.logId;
        if (value.error != null) result['error'] = tError.toJson(value.error);
        if (value.details != null) result['details'] = value.details;
        return result;
    }

    toJson(tError: Igor.Json.IJsonSerializer<TError>): Igor.Json.JsonValue {
        return BadRequestError.toJson<TError>(this, tError);
    }

    static instanceJsonSerializer<TError>(tError: Igor.Json.IJsonSerializer<TError>): Igor.Json.IJsonSerializer<BadRequestError<TError>> {
        return {
            toJson(value: BadRequestError<TError>): Igor.Json.JsonValue {
                return value.toJson(tError);
            },

            fromJson(json: Igor.Json.JsonValue): BadRequestError<TError> {
                return BadRequestError.fromJson<TError>(json, tError);
            }
        };
    }
}

export class UnauthorizedError extends Error implements HttpError {
    message: string = "Access denied. Please provide authentication data";
    logId?: string | null = null;

    constructor() {
        super('UnauthorizedError');
        Object.setPrototypeOf(this, new.target.prototype);
    }

    static fromJson(json: Igor.Json.JsonValue): UnauthorizedError {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new UnauthorizedError();
        obj.message = ('message' in jsonObject && jsonObject['message'] != null) ? jsonObject['message'] as string : "Access denied. Please provide authentication data";
        obj.logId = ('log_id' in jsonObject && jsonObject['log_id'] != null) ? jsonObject['log_id'] as string : null;
        return obj;
    }

    static toJson(value: UnauthorizedError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['message'] = value.message;
        if (value.logId != null) result['log_id'] = value.logId;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return UnauthorizedError.toJson(this);
    }
}

export class ForbiddenError extends Error implements HttpError {
    message: string = "Access denied. You are not authorized to perform this action";
    logId?: string | null = null;

    constructor() {
        super('ForbiddenError');
        Object.setPrototypeOf(this, new.target.prototype);
    }

    static fromJson(json: Igor.Json.JsonValue): ForbiddenError {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ForbiddenError();
        obj.message = ('message' in jsonObject && jsonObject['message'] != null) ? jsonObject['message'] as string : "Access denied. You are not authorized to perform this action";
        obj.logId = ('log_id' in jsonObject && jsonObject['log_id'] != null) ? jsonObject['log_id'] as string : null;
        return obj;
    }

    static toJson(value: ForbiddenError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['message'] = value.message;
        if (value.logId != null) result['log_id'] = value.logId;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ForbiddenError.toJson(this);
    }
}

export class NotFoundError extends Error implements HttpError {
    message: string = "Requested resource not found";
    logId?: string | null = null;

    constructor() {
        super('NotFoundError');
        Object.setPrototypeOf(this, new.target.prototype);
    }

    static fromJson(json: Igor.Json.JsonValue): NotFoundError {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new NotFoundError();
        obj.message = ('message' in jsonObject && jsonObject['message'] != null) ? jsonObject['message'] as string : "Requested resource not found";
        obj.logId = ('log_id' in jsonObject && jsonObject['log_id'] != null) ? jsonObject['log_id'] as string : null;
        return obj;
    }

    static toJson(value: NotFoundError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['message'] = value.message;
        if (value.logId != null) result['log_id'] = value.logId;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return NotFoundError.toJson(this);
    }
}

export class ConflictError<TError> extends Error implements HttpError {
    message: string = "Could not complete due to a conflict with the current state of the resource";
    logId?: string | null = null;
    error?: TError | null = null;
    details?: Igor.Json.JsonValue | null = null;

    constructor() {
        super('ConflictError');
        Object.setPrototypeOf(this, new.target.prototype);
    }

    static fromJson<TError>(json: Igor.Json.JsonValue, tError: Igor.Json.IJsonSerializer<TError>): ConflictError<TError> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ConflictError<TError>();
        obj.message = ('message' in jsonObject && jsonObject['message'] != null) ? jsonObject['message'] as string : "Could not complete due to a conflict with the current state of the resource";
        obj.logId = ('log_id' in jsonObject && jsonObject['log_id'] != null) ? jsonObject['log_id'] as string : null;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? tError.fromJson(jsonObject['error']) : null;
        obj.details = ('details' in jsonObject && jsonObject['details'] != null) ? jsonObject['details'] : null;
        return obj;
    }

    static toJson<TError>(value: ConflictError<TError>, tError: Igor.Json.IJsonSerializer<TError>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['message'] = value.message;
        if (value.logId != null) result['log_id'] = value.logId;
        if (value.error != null) result['error'] = tError.toJson(value.error);
        if (value.details != null) result['details'] = value.details;
        return result;
    }

    toJson(tError: Igor.Json.IJsonSerializer<TError>): Igor.Json.JsonValue {
        return ConflictError.toJson<TError>(this, tError);
    }

    static instanceJsonSerializer<TError>(tError: Igor.Json.IJsonSerializer<TError>): Igor.Json.IJsonSerializer<ConflictError<TError>> {
        return {
            toJson(value: ConflictError<TError>): Igor.Json.JsonValue {
                return value.toJson(tError);
            },

            fromJson(json: Igor.Json.JsonValue): ConflictError<TError> {
                return ConflictError.fromJson<TError>(json, tError);
            }
        };
    }
}

export class InternalServerError extends Error implements HttpError {
    message: string = "Could not process the request due to server error. Please contact developers";
    logId?: string | null = null;

    constructor() {
        super('InternalServerError');
        Object.setPrototypeOf(this, new.target.prototype);
    }

    static fromJson(json: Igor.Json.JsonValue): InternalServerError {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new InternalServerError();
        obj.message = ('message' in jsonObject && jsonObject['message'] != null) ? jsonObject['message'] as string : "Could not process the request due to server error. Please contact developers";
        obj.logId = ('log_id' in jsonObject && jsonObject['log_id'] != null) ? jsonObject['log_id'] as string : null;
        return obj;
    }

    static toJson(value: InternalServerError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['message'] = value.message;
        if (value.logId != null) result['log_id'] = value.logId;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return InternalServerError.toJson(this);
    }
}
